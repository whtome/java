二叉树前序遍历:最自然访问方式，来输出二叉树

深度优先遍历的非递归实现:模拟操作系统栈
借助栈

二分搜索树的中序遍历:排序后的结果

二叉树的后序遍历:内存释放

二叉树的层序遍历:广度优先遍历
借助队列

一般用于无权图最短路径
用于搜索策略

基础面试题:
4
5
6

1 2 3的非递归版本
进阶面试题
2

二分搜索树最大最小值

最小值
一直递归向左走直到走不动为止，此时节点即为所求

最大值
一直递归向右走直到走不动为止，此时节点即为所求

删除任意值节点
Hibbard Deletion
找到该节点的前驱或后继节点，替换之。

前驱节点:以当前root为根节点的二叉树中小于root的最大值节点

后继节点

二分搜索树的floor与ceil
floor:小于该值在二叉树的最大值节点
ceil:大于该值在二叉树中的最小值节点

rank:给每个节点排序输出值
select

二分搜索树:结构不做要求，但是对于值有要求

查找时间复杂度:O(height) 与树高成正比
O(log2 n); n-节点个数

[1,2,4,5,6,7,8,9]
二分搜索树的极端情况:若只有左子树或右子树，此时BST退化为链表
时间复杂度退化为O(n)级别

解决二分搜索树在极端条件下退化为链表的问题:
平衡二分搜索树:
AVL 
红黑树
2-3
Splay树(拓展树)


平衡二叉树:每个节点的左右两个子树高度差不超过1

基础题:
7/8
进阶:
3.4.5



