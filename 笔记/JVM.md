JDK：Java开发工具

JRE：Java运行环境

JVM：Java虚拟机（对应平台的虚拟机，不跨平台）



从JDK1.3至今，HotSpot为默认JVM



JVM内存区域划分 -> 判断对象是否存活 -> 垃圾回收算法 -> 垃圾回收器 -> JVM性能检测



三      Java内存区域划分  --  共六块内存



3.1 线程私有内存：每个线程都有，彼此之间完全隔离

3.1.1   程序计数器 

   程序计数器是比较小的内存空间，当前线程所执行的字节码的行号指示器。

   若当前线程执行的是Java方法，计数器记录的是正在执行的JVM字节毛指令地址；

   若当前线程执行的是Native方法，计数器值为空。

   程序计数器是唯一一块不会产生OOM异常的区域。



3.1.2   虚拟机栈--java方法执行的内存模型

虚拟机栈描述Java方法的内存模型。

每个方法执行的同时都会创建一个栈帧存储局部变量表，操作数栈，方法出口等信息。每个方法从调用直到执行完毕的过程，对应一个栈帧在虚拟机栈的入栈与出栈过程。

生命周期与线程相同：在创建线程的同时创建此线程的虚拟机栈，线程执行结束，虚拟机栈与线程一同被回收。

局部变量表：存放编译器可知的的各种基本数据类型（8大基本数据类型），对象引用。

此区域一共会产生两种异常：

a . 若线程请求的栈深度大于JVM允许的深度（-Xss设置栈容量），抛出StackOverFlowError异常.(单线程)

b . 虚拟机在进行栈的动态扩展时，若无法申请到足够内存，抛出OOM（OutOfMemoryError）异常。（多线程）



3.1.3  本地方法栈

本地方法（native方法）执行的内存模型，其他与虚拟机栈完全相同。

HotSpot虚拟机中，本地方法栈与虚拟机栈是同一块内存区域。



3.2 线程共享内存：所有线程共享此内存空间，此空间对所有线程可见。

3.1.4   堆（GC堆）

   Java堆（Java  Heap）是JVM管理的最大内存区域。在JVM启动是创建，所有线程共享此内存，此内存中存放的都是对象实例及数组。

Java堆是垃圾回收器管理的最主要内存区域。Java堆可以处于物理上不连续的内存空间。-Xmx设置堆最大值 ， -Xms设置堆最小值

若在堆中没有足够的内存完成对象实例分配并且堆无法再次扩展时。抛出OOM异常。

OOM：

内存溢出：内存中的对象确实还应该存活，但由于堆内存不够用产生的异常。

内存泄露：无用对象无法被GC



3.1.5   方法区

用于存储已被JVM加载的类信息，常量，静态变量等数据。JDK8以前，方法区也叫”永久代“，JDK8之后称为元空间（Meta Space）

方法区无法满足内存分配需求时，抛出OOM



3.1.6 运行时常量池

运行时常量池是方法区的一部分，存放字面量与符号引用。

字面量：字符串常量（JDK1.7移到堆中），final常量，基本数据类型的值。

符号引用：类，字段，方法的完全限定名，名称，描述符。



4. 判断对象是否已死

4.1 引用计数法

算法思想：给每个对象附加一个计数器，没当有一个地方引用此对象时，计数器+1；每当有一个引用失效时，计数器-1；在任意时刻，只要计数器值为0的对象就是不能再被引用的，即对象已死。

引用计数法实现简单，判断效率也较高。python使用引用计数法来管理内存。

但是无法解决循环引用问题。

JVM并未采用此算法。



4.2 可达性分析算法

Java采用可达性分析算法来判断对象是否存活（c#，Lisp）

核心思想：通过一系列“GC Roots”的对象作为起点，从这些节点开始向下搜索对象，搜索走过的路径，称为“引用链”，当一个对象到任意一个GC Roots对象没有任何的引用链相连时（从GC Roots到对象不可达），证明对象已死。

Java中能作为GC Roots的对象包含一下四种：

a.  虚拟机栈中引用的对象

b.  类静态变量引用的对象

c.  常量引用的对象

d.  本地方法栈中引用的对象

****JDK1.2之后对于引用的概念做了扩充****

将引用分为强引用（Strong Reference），软引用（Soft Reference），弱引用（Weak Reference），虚引用（Phantom Reference）四种，这四种强度依次递减。

a.强引用：强引用指的是代码中普遍存在的，类似于Object obj = new Object()；在JVM中只要强引用还存在，垃圾回收器永远不会回收此对象实例。

b.软引用：软引用用来描述一些有用但不必须对象。对于仅被软引用指向的对象，在系统将要发生内存溢出之前，会将所有软引用对象进行垃圾回收；若内存够用，这些对象仍然保留。在JDK1.2之后提供SoftReference类来实现软引用。

c.弱引用：弱引用也是描述非必须对象的，但是比软引用更差一点。仅被弱引用关联的对象最多只能生存到下一次GC开始之前。当垃圾回收器开始工作是，无论当前内存是否够用，都会回收掉仅被弱引用关联的对象。JDK1.2以后，使用WeakReference类来实现弱引用。

d.虚引用：虚引用也称为幽灵引用或幻影引用，是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生产时间产生影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用的唯一目的就是在这个对象被GC之前，收到一个系统通知。JDK1.2以后，提供PhantomReference类来实现虚引用。



4.3 对象的自我拯救 -- finalize

finalize()只会被系统调用一次

```
protected void finalize() throws Throwable
```

在可达性分析方法中不可达的对象，并非“非死不可”，所有不可达对象处于“缓刑”阶段

要宣告一个对象的彻底死亡，需要经历两次标记过程：

若对象在进行可达性分析之后，发现到GC Roots不可达，此对象会进行第一次标记并且进行一次筛选过程。筛选的条件是此对象是否有必要执行finalize()。当对象没有覆盖finalize()方法或finalize()方法已经被JVM调用过，JVM会将此对象彻底宣判死亡。

筛选成功（对象覆写了finalize方法并且位被执行），会将此对象放入F-Queue，如果对象在finalize()成功自救（此对象与GC Roots建立联系），则对象会在第二次会被移除回收集合，成功存活；若对象在finalize中仍然与GC Roots不可达，宣告死亡。



4.4 回收方法区

方法区回收主要回收两部分内容：废弃常量和无用的类

判断一个类是无用类，必须满足以下三个条件：

i. 该类的所有实例都已经被回收（Java堆中不存在该类的任何实例）

ii. 加载该类的类加载器已经被回收

iii. 该类的Class对象没有在任何其他地方被引用，也无法通过反射访问该类的所有内容