JDK：Java开发工具

JRE：Java运行环境

JVM：Java虚拟机（对应平台的虚拟机，不跨平台）

JMM：Java内存模型（逻辑概念，描述共享程序的结构）



从JDK1.3至今，HotSpot为默认JVM



JVM内存区域划分 -> 判断对象是否存活 -> 垃圾回收算法 -> 垃圾回收器 -> JVM性能检测



三      Java内存区域划分  --  共六块内存



3.1 线程私有内存：每个线程都有，彼此之间完全隔离，生命周期与具体线程相同，随着线程的创建而创建，随着线程销毁，对应空间回收。

3.1.1   程序计数器 

   程序计数器是比较小的内存空间，当前线程所执行的字节码的行号指示器。

   若当前线程执行的是Java方法，计数器记录的是正在执行的JVM字节码指令地址；

   若当前线程执行的是Native方法，计数器值为空。

   程序计数器是唯一一块不会产生OOM异常的区域。



3.1.2   虚拟机栈--java方法执行的内存模型

虚拟机栈描述Java方法的内存模型。

每个方法执行的同时都会创建一个栈帧存储局部变量表，操作数栈，方法出口等信息。每个方法从调用直到执行完毕的过程，对应一个栈帧在虚拟机栈的入栈与出栈过程。

生命周期与线程相同：在创建线程的同时创建此线程的虚拟机栈，线程执行结束，虚拟机栈与线程一同被回收。

局部变量表：存放编译器可知的的各种基本数据类型（8大基本数据类型），对象引用。

此区域一共会产生两种异常：

a . 若线程请求的栈深度大于JVM允许的深度（-Xss设置栈容量），抛出StackOverFlowError异常.(单线程)

b . 虚拟机在进行栈的动态扩展时，若无法申请到足够内存，抛出OOM（OutOfMemoryError）异常。（多线程）



3.1.3  本地方法栈

本地方法（native方法）执行的内存模型，其他与虚拟机栈完全相同。

HotSpot虚拟机中，本地方法栈与虚拟机栈是同一块内存区域。



3.2 线程共享内存：所有线程共享此内存空间，此空间对所有线程可见。

3.1.4   堆（GC堆）

   Java堆（Java  Heap）是JVM管理的最大内存区域。在JVM启动是创建，所有线程共享此内存，此内存中存放的都是对象实例及数组。

Java堆是垃圾回收器管理的最主要内存区域。Java堆可以处于物理上不连续的内存空间。-Xmx设置堆最大值 ， -Xms设置堆最小值

若在堆中没有足够的内存完成对象实例分配并且堆无法再次扩展时。抛出OOM异常。

OOM：

内存溢出：内存中的对象确实还应该存活，但由于堆内存不够用产生的异常。

内存泄露：无用对象无法被GC



3.1.5   方法区

用于存储已被JVM加载的类信息，常量，静态变量等数据。JDK8以前，方法区也叫”永久代“，JDK8之后称为元空间（Meta Space）

方法区无法满足内存分配需求时，抛出OOM



3.1.6 运行时常量池

运行时常量池是方法区的一部分，存放字面量与符号引用。

字面量：字符串常量（JDK1.7移到堆中），final常量，基本数据类型的值。

符号引用：类，字段，方法的完全限定名，名称，描述符。



4. 判断对象是否已死

4.1 引用计数法

算法思想：给每个对象附加一个计数器，每当有一个地方引用此对象时，计数器+1；每当有一个引用失效时，计数器-1；在任意时刻，只要计数器值为0的对象就是不能再被引用的，即对象已死。

引用计数法实现简单，判断效率也较高。python使用引用计数法来管理内存。

但是无法解决循环引用问题。

JVM并未采用此算法。



4.2 可达性分析算法

Java采用可达性分析算法来判断对象是否存活（c#，Lisp）

核心思想：通过一系列“GC Roots”的对象作为起点，从这些节点开始向下搜索对象，搜索走过的路径，称为“引用链”，当一个对象到任意一个GC Roots对象没有任何的引用链相连时（从GC Roots到对象不可达），证明对象已死。

Java中能作为GC Roots的对象包含一下四种：

a.  虚拟机栈中引用的对象

b.  类静态变量引用的对象

c.  常量引用的对象

d.  本地方法栈中引用的对象

****JDK1.2之后对于引用的概念做了扩充****

将引用分为强引用（Strong Reference），软引用（Soft Reference），弱引用（Weak Reference），虚引用（Phantom Reference）四种，这四种强度依次递减。

a.强引用：强引用指的是代码中普遍存在的，类似于Object obj = new Object()；在JVM中只要强引用还存在，垃圾回收器永远不会回收此对象实例。

b.软引用：软引用用来描述一些有用但不必须对象。对于仅被软引用指向的对象，在系统将要发生内存溢出（抛出OOM异常）之前，会将所有软引用对象进行垃圾回收；若内存够用，这些对象仍然保留。在JDK1.2之后提供SoftReference类来实现软引用。（缓存）

c.弱引用：弱引用也是描述非必须对象的，但是比软引用更差一点。仅被弱引用关联的对象最多只能生存到下一次GC开始之前。当垃圾回收器开始工作是，无论当前内存是否够用，都会回收掉仅被弱引用关联的对象。JDK1.2以后，使用WeakReference类来实现弱引用。

d.虚引用：虚引用也称为幽灵引用或幻影引用，是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生产时间产生影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用的唯一目的就是在这个对象被GC之前，收到一个系统通知。JDK1.2以后，提供PhantomReference类来实现虚引用。



4.3 对象的自我拯救 -- finalize

finalize()只会被系统调用一次

```
protected void finalize() throws Throwable
```

在可达性分析方法中不可达的对象，并非“非死不可”，所有不可达对象处于“缓刑”阶段

要宣告一个对象的彻底死亡，需要经历两次标记过程：

若对象在进行可达性分析之后，发现到GC Roots不可达，此对象会进行第一次标记并且进行一次筛选过程。筛选的条件是此对象是否有必要执行finalize()。当对象没有覆盖finalize()方法或finalize()方法已经被JVM调用过，JVM会将此对象彻底宣判死亡。

筛选成功（对象覆写了finalize方法并且未被执行），会将此对象放入F-Queue，如果对象在finalize()成功自救（此对象与GC Roots建立联系），则对象会在第二次会被移除回收集合，成功存活；若对象在finalize中仍然与GC Roots不可达，宣告死亡。



面试题：请解释final，finally，finalize的区别



final：终结器

finally：异常体系中保证重点代码（流的关闭，数据库关闭等）一定会被执行的机制

finalize：对象的自我拯救





4.4 回收方法区

方法区回收主要回收两部分内容：废弃常量和无用的类

判断一个类是无用类，必须满足以下三个条件：

i. 该类的所有实例都已经被回收（Java堆中不存在该类的任何实例）

ii. 加载该类的类加载器已经被回收

iii. 该类的Class对象没有在任何其他地方被引用，也无法通过反射访问该类的所有内容





4.5 垃圾回收算法

标记-清除算法：产生大量的不连续的内存碎片

复制算法：

新生代复制算法：大部分对象朝生夕死，将新生代内存分为一块较大的Eden区和两块较小的Survivor区域（默认8：1：1），每次使用Eden和一块Survivor区，在发生GC时，将使用区域的存活对象复制到另一块Survivor区，然后把使用的区域一次性清除，不断重复。若对象在Survivor区域中来回复制若干次（默认15次），将此对象移动到老年代区域。

标记-整理算法：



4.6 内存分配策略



对象优先在Eden区产生

大对象（大数组）直接进入老年代

在新生代中长期存活的对象将进入老年代

动态对象年龄判定：如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间（一块Survivor空间）的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。



4.7 JDK中常用的JVM检测工具：命令行工具

命令名称 全称 用途
jps：  JVM Process Status Tool 显示指定系统内所有的HotSpot虚拟机进程
jstat ： JVM Statistics  Monitoring Tool 用于收集Hotspot虚拟机各方面的运行数据
jinfo ：Configuration Info for Java 显示虚拟机配置信息
jmap： JVM Memory Map 生成虚拟机的内存转储快照，生成heapdump文件
jhat： JVM Heap Dump Browser 用于分析heapdump文件，它会建立一个HTTP/HTML服务器，让用户在浏览器上查看分析结果
jstack： JVM Stack Trace 显示虚拟机的线程快照



jps：返回当前操作系统中所有JVM进程ID 

jmap：生出JVM内存快照

jstack：生出当前JVM的线程快照



4.8 java内存模型

并发程序三大问题：只有当以下三个特性同时满足的程序才是线程安全的。

可见性：一个线程修改了共享变量的值，其他线程能立即得到此修改

原子性：一个或多个操作在CPU的执行过程中不被打断

有序性：按照代码顺序一次执行



线程的工作内存：每个线程都有自己的一块内存，并且线程之间的工作内存完全隔离



volatile变量规则

1. 可见性

volatile变量的写操作对于所有线程都是立即得知的（可见性）

2. 禁止指令重排（有序性）
3. 双重加锁单例模式

```
class Singleton{
    private volitile static singleton;
    private Singleton() {}
    public static Singleton getInstance() {
        if(singleton == null) {
            //同步
            synchronized(Singleton.class) {
               //保证多线程场景下值new了一次
               if(singleton == null) {
                    singleton =new Singleton();
               }
            }
        }
        return singleton;
    }
}
```

a. 在堆上开空间

b. 栈上分配空间指向堆地址 

c. 对象的属性初始化

