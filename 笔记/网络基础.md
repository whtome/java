# 网络基础

### 网络的发展背景/TCP/IP五层协议/数据的传输流程



#### 网络的发展背景：

在网络中随着网络的覆盖范围不同，划分出了几种网络：局域网，城域网，广域网，因特网，互联网，以太网，令牌环网



**IP地址：在网络中唯一表示一台主机  IPV4/IPV6**

​             IPV4：  uint32_t  ---   无符号32位整数  ----   IP地址不到43亿

​                          DHCP,NAT

​             IPV6：uint8_t  ip[16]  ---  因为不向前兼容IPV4，因此没有很好的推广起来

​            在网络中每条信息都会包含两条信息：源端IP地址，目的端IP地址



**PORT端口： 在一台主机上唯一表示一个进程**

​              uint16_t   ---   无符号16位整数

​              范围：0~65535

​             特性：一个端口只能被一个进程占用，但是一个进程可以使用多个端口

​               在网络中每条数据都包含两条信息：源端端口，目的端端口

协议：通信双方数据格式的约定



##### 协议分层：

​         协议的封装，在整个通信环境中使用起来更加的方便

​         按照每一层提供的服务，使用的协议，提供的接口，对复杂的网络环境进行分层

##### 网络通信环境中的协议分层：

​         OSI七层参考模型：

​              应用层-》表示层-》会话层-》传输层-》网络层-》链路层-》物理层

​          TCP/IP五层模型：

​                应用层-》传输层-》网络层-》链路层-》物理层

​           应用层：负责应用程序之间的数据沟通； HTTP/FTP/DNS/DHCP

​           传输层：负责端与端之间的数据传输；TCP/UDP

​           网络层：负责地址管理与路由选择；  IP；路由器

​           链路层：负责相邻设备之间的数据传输（MAC地址）；Ether；交换机

​           物理层：负责光电信号的传输；以太网协议；集线器



![1563249015213](C:\Users\ADMINI~1\AppData\Local\Temp\1563249015213.png)



#### TCP/IP四层协议中的典型协议解析以及特性讲解



#### 应用层：负责应用程序之间的数据沟通

​            知名协议：

​                        HTTP协议（超文本传输协议）

​                        网址-URL（统一资源定位符）：https://www.baidu.com

![1563323161796](C:\Users\ADMINI~1\AppData\Local\Temp\1563323161796.png)

![QQ截图20190716120414](C:\Users\Administrator\Desktop\QQ截图20190716120414.png)

​                  协议方案名称：//用户名:密码@服务器地址:端口号/请求资源路径？查询字符串#片段表示符   

​                   URL编码/解码：

​                   查询字符串是用户提交给服务器的数据信息，这些提交的数据中若是出现特殊字符，则有可能与URL中间隔符产生歧义导致url解析失败；因此查询字符串中不能出现特殊字符；若是提交的数据中真的又存在特殊字符血药对查询字符串的数据进行url编码操作；编码之后的数据在对端需要进行url解码操作。

​            url编码：将特殊字符每一个字符转换为16进制数字字符串，并且为了表明这两个字符是经过了url编码后的数据，需要在转换后的数据前加上%                +   -->   %2b

​           url解码：当遇到%，则认为紧跟其后的两个字符需要转码，将第一个字符转换为数字左移4为与第二个字符转换后的数据进行相加                 %2b -->     (’2‘ - ’0‘) << 4  +  ('b' - 'a' +10)   -->   43 -- >+

​          **HTTP协议：**

​                首行: 

​                       请求首行：请求方法    URL   协议版本

​                              请求方法：（GET/POST）  get没有正文，提交的数据在url查询字符串中

​                               协议版本：0.9/1.0/1.1/2

​                       响应首行：协议版本  响应状态码   状态码描述信息

​                               响应状态码：

​                                   1xx：Informational(信息状态码)                        接收的请求正在处理

​                                   2xx：Success（成功状态码）                             请求正常处理完毕

​                                   3xx：Redirection（重定向状态码）                   需要进行附加操作以完成请求

​                                   4xx：Client Error（客户端错误状态码）           服务器无法处理请求

​                                   5xx：Server Error（服务器错误状态码）          服务器处理请求出错

​                     常见的状态码：202（OK），404（Not  Found），403（Forbidden（被禁止）），302（Redirect，重定向），504（Bad  Gateway(无效/错误网关)）

​               头部：以一个个key : value组成的键值对，并且各个键值对之间以/r/n作为间隔

​                         ![1563251045231](C:\Users\ADMINI~1\AppData\Local\Temp\1563251045231.png)

​               空行：/r/n            ---用于间隔头部与正文

​               正文：

![1563323510563](C:\Users\ADMINI~1\AppData\Local\Temp\1563323510563.png)

HTTP的其他方法：

​                        PUT：传输文件

​                        HEAD：获取报文首部

​                       DELETE /   OPTIONS   /  CONNECT  /  LINK等

#### 传输层：负责端与端之间的数据传输；  TCP/UDP

端口：在一个主机上表示一个进程（标识接收到的数据应该交给哪个进程处理）

​           一个端口只能被一个进程占用；但一个进程可以使用多个端口

​          uint16_t   无符号16为整数：端口号0~65535       0~1023不推荐使用

五元组：在网络通信中的每一条数据都必须带有一些关键信息（**源IP地址/源端口/目的IP地址/目的端口/协议**）用于标识网络中的每一条通信

**UDP协议：用户数据报协议 -------  无连接，不可靠，面向数据报**

​      无连接，不可靠：通信时不需要建立连接，只需要知道对端地址信息，就可以发送数据

​      面向数据包：数据只能一整条一整条的向应用层交付

​      udp协议字段： 16位源/目的端口    16为数据报长度    16位校验和

​       16位数据报长度：用于指定整个udp数据报的长度（包含头部）



​             ![1563251963521](C:\Users\ADMINI~1\AppData\Local\Temp\1563251963521.png)

​        16位数据报长度决定了一个udp协议的数据data长度不能大于64k-8，否则发送失败

​         因此当数据长度大于64k-8式，就需要用户在应用层进行数据分包，将数据讽刺一个个小于64k-8大小的数据段；

​         udp并不能保证数据有序到达，需要用户在应用层进行包序管理

​         用户每次调用发送接口发送数据的时候，udp会直接为这条数据封装udp头部信息，直接发送出去

​         为了防止用户接收半条数据，导致udp剩余数据无法根据协议字段中数据报长度确定数据长度，因此udp规定数据只能整条交付

应用层在传输层基于udp实现的协议：DNS/DHCP



UDP如何实现可靠传输：模仿tcp可靠传输



**TCP协议：面向连接，可靠传输，面向字节流**：

![1563328685263](C:\Users\ADMINI~1\AppData\Local\Temp\1563328685263.png)



![1563328767646](C:\Users\ADMINI~1\AppData\Local\Temp\1563328767646.png)



**tcp三次握手与四次挥手流程以及状态变化**

为什么握手是三次而挥手是四次：

握手三次：两次不安全，四次没必要

​                    有可能SYN会延迟，缺乏保护的情况下，收到一个SYN就会建立一个新的socket，完整的状态保护避免对一个客户端创建多个socket.

​                    服务端无法通过客户端syn确定客户端具有收发数据的能力，需要再次进行SYN确认。

挥手四次：

​                   被动关闭方，收到FIN之后对其进行ACK回复，但是不能直接关闭socket，因为这时候用户有可能正在处理数据（socket接收缓冲区中有可能还有堆积的数据），需要用户确认什么时候关闭socket发送FIN；因此ACK不能和FIN放在一起。



若是三次握手失败，服务端如何处理？

​              服务端超时等待ACK之后，向客户端发送rst报文，然后释放新建的socket资源

*syn泛洪攻击---调研一下*



**主动关闭方TIME_WAIT状态的作用：**

1. 假设没有time_wait而是直接进入closed状态，释放资源会造成的危害

​         在主动关闭方发送的最后一次ACK丢失的情况下：

​          如果主动关闭方使用相同的地址信息立即重启

​                     1.收到被动关闭方超时等待后重发的FIN包，对新连接造成影响

​                     2.发送SYN请求，但是对方等待的是ACK，因为状态不对导致对新连接造成影响

2. 因此主动关闭方需要等待一段时间：2个MSL时间

   ​           若是对方重发FIN请求，可以对其再次进行确认回复

   ​           MSL：报文最大生命周期    30秒

   ​           等待俩个msl时间爱你是为了让**网络中延迟的报文**都消失在网络中，不会对后续连接造成影响

   ​                                                              后续重传的FIN和ACK

​     大量time_wait解决方案：调整等待时间，设置套接字选项（地址复用）



**可靠传输：**

​         **面向连接**

​         **确认应答机制**：对每一条数据，向发送方进行确认回复

​         **超时重传机制**：发送数据后等待一段时间（200ms）若是没有收到确认回复，则认为数据丢失，进行重传

​         **协议字段中的**：序号+确认序号（保证数据有序的向应用层交付）

​         **协议字段中的：校验和**（校验接收的数据与发送的数据是否一致，不一致则发送重传请求，否则确认回复）

![1563333759410](C:\Users\ADMINI~1\AppData\Local\Temp\1563333759410.png)



tcp为了保证可靠传输，牺牲了部分性能（有些性能的损失是没必要的，比如ack丢失导致的重传）

tcp又采用了几种机制来避免无谓的性能损失以及提高性能的方法

1. **滑动窗口机制：**

![1563334998938](C:\Users\ADMINI~1\AppData\Local\Temp\1563334998938.png)

流量控制：

通过协议字段中窗口大小（不会大于接收方的接收缓冲区中剩余空间大小）字段控制发送方发送的数据大小；避免因为发送过快而接收方处理过慢导致接收区数据放满后，大量的数据丢失重传降低的性能；

窗口大小在每次对数据进行确认回复的时候都会进行重新协商。

每一条确认回复，中的确认序号，都要保证之前的数据已经完全收到

没有收到第一条回复，但是收到第二条回复，认为第一条和第二条都已经正确传输，避免因为ack丢失而导致的数据重传。



快速重传机制：

接收方收到了第二条数据，但是没有收到第一条，则认为第一条数据丢失，则立即发送第一条数据的重传请求，并且连续发送三次；当发送方连续收到三次重传请求时，就不需要等待超时，直接对这条数据进行重传；

连续三次，是因为要避免因为网络阻塞，数据延迟到达而导致的重传



![1563335660062](C:\Users\ADMINI~1\AppData\Local\Temp\1563335660062.png)

拥塞控制：

网络通信开始时，并不会直接发送窗口大小的数据，而是以一种慢启动，快增长的形式进行数据传输，起到一个网络探测的作用，避免开始通信是因为网络不好导致的发送数据越多，丢失数据越多的重传性能损失，在快增长的过程中，若出现丢包则初始化拥塞窗口大小，重新开始探测网络状况。



2. **延迟应答机制**：

   接收方接收数据若是立即回复，则窗口大小会降低，会导致传输速度降低，因此接收方接收到数据后，并不立即回复，而是延迟一会（不超过500ms），在这期间，用户可又能将数据从接受缓冲区中取出，可以尽最大的能力保证窗口大小，保证传输速度不会降低。

3. **捎带应答机制：**

​        每次接收方对发送的数据进行确认回复，若是单独发送一个数据报（仅包含一个tcp报头）是不划算的，解决方案就是将要进行的确认回复和即将要发送的数据合到一起进行发送，就可省略一个tcp报头的发送，减少网络中不必要的流量信息。

**tcp的可靠传输：**

​           **连接管理，确认应答，超时重传，序号/确认序号，校验和**

​           **减少性能损失及提高性能：滑动窗口机制（流量管理，拥塞控制，快速重传），延迟应答，捎带应答**



##### 面向字节流：

​          数据不会直接发送，而是放到缓冲区中，操作系统选择一个合适大小的数据以字节流的形式发送出去，对方接收数据时可以一次性接收所有数据，也可以一次接收一点，分多次接收。

![1563341659965](C:\Users\ADMINI~1\AppData\Local\Temp\1563341659965.png)

tcp面向字节流特性：传输灵活，但是会造成粘包问题

粘包问题：tcp传输的数据在发送缓冲区或者接收缓冲区中堆积，因为tcp数据收发的灵活性，导致有可能多条数据当作一条接收；（两条数据的粘连）

tcp粘包的本质问题：tcp在传输层，对数据的格式并不关心，对数据之间没有边界区分因此造成的数据粘包。

粘包是tcp在传输层对数据边界不敏感，因此需要用户在应用层进行数据边界管理：

​        特殊字符间隔             定长数据          不定长数据在应用协议头中声明数据长度



**tcp连接管理中的保活机制：**

​     若是通信双方，长时间（7200s）没有数据往来，则会向对方发送保活探测数据报（要求对方对这个数据报进行回复），若是收到回复则认为连接正常，若是间隔（7s）发送连续多次（9次）没有收到回复，则认为连接断开

​     tcp连接断开的体现：

​        recv返回0；send触发SLGPIPE异常

​      tcp异常连接断开的情况：断电



##### tcp协议字段：

16位源/目的端口：负责端与端之间的数据传输

32位序号/确认序号：保证数据有序交付

4位头部长度：解析时tcp头部，以4字节为单位（tcp头部最小20字节，最大60字节）

6位标志位：URG/ACK/PSH/RST/SYN/FIN

16位窗口大小：实现滑动窗口，以及进行流量控制

16位校验和：保证数据一致性

16位紧急指针：带外数据

40字节的选项数据：可有可无





#### 网络层：负责地址管理与路由选择；  IP；路由器

​         路由选择：在复杂的网络环境中为每一条数据都选择一条合适的路径

![1563343317702](C:\Users\ADMINI~1\AppData\Local\Temp\1563343317702.png)

主机：个人PC设备          路由器：路由转发设备            节点：网络中任意设备



![1563343912043](C:\Users\ADMINI~1\AppData\Local\Temp\1563343912043.png)

​     在网络中的IP地址不能随意分配，因为随意分配很容易造成IP地址冲突；因此IP地址需要得到合理的管理才可以

​      一个路由器可以组建一个局域网，这时候路由器向局域网中主机分配IP地址的时候，就必须带有自己的网络的标识----网络号；这时候只需要将每个网络的网络号规范起来就可以避免IP地址冲突。

​      在一个局域网中，路由器向主机分配IP地址，还要能在局域网中标识这个主机，这个表示叫主机号

​       IP的组成：网络号+主机号

​       保证相邻的网络不能具有相同的网络号就可以尽可能的避免IP地址冲突，一个路由器上相连的所有网络网络号不能相同，因为这些网络都是相邻网络，数据到了路由器上之后，一旦网络号冲突就会导致路由器不知道数据该给谁。



![1563345719658](C:\Users\ADMINI~1\AppData\Local\Temp\1563345719658.png)

​     在一个网络中，并不是所有的主机号都能分配给主机

​      主机号全为0的IP地址 ---  网路号，用于标识一个网络

​      主机号全为1的IP地址 ---  udp广播地址

​      127.0.0.1        本机虚拟回环网卡地址 ---  用于本机的网络测试

​      在RFC1918中进行规定，用于组建私网的网段也不能随意使用

​      只有以下几个网段能够用于组建私网：

​             10.x.x.x       172.16.x.x ~172.31.x.x            192.168.x.x

​      相邻的网络不能使用相同的网络号



路由选择：

​         路由表：每个路由器上都有一个路由表，记录的连接在路由器上的网络

​         Destination            Gateway                   Genmask                 Iface（路由器组建局域网的网卡--网关地址）

​         192.169.122.0                                        255.255.255.0           eth1

​         192.168.10.0                                           255.255.255.0           eth0

​         default:

​                                       192.168.10.1                                                 eth0



**ip协议字段：**

4位协议版本：IPV4/IPV6

4位头部长度：IP报文头最大长度60个字节（以4字节为单位）

8位服务类型：4位TOS字段（最小延时/最大吞吐量/最高可靠习性/最小成本），1位保留位

16位报文长度：限制一个IP报文最大长度64K               udp数据最大长度：64K - 20 - 8



MTU ：最大传输单元

当mtu<udp数据长度<64k - 20 - 8时，链路层则不支持大于mtu大小的数据传输，这时候网络先获取下层mtu大小，在网络层对数据进行分片。



16位标识：udp数据有可能在网络层进行数据分片，这个标识则可以指定当前分片属于哪个udp数据包

3位标志：1位启用，1位标识是否禁止分片，1位用于标识分片末尾

13位片偏移：用于指定udp数据分片相对于udp数据包起始位置的偏移量（分片在数据包中的位置）

​                       偏移量是以8字节为单位，每个分片都是8的整数倍长度（除最后一个分片）

8位ttl：报文生命周期，最大经过的路由器跳数

8位上层协议：用于数据分用，决定由上层哪个协议进行解析

16位校验和：校验数据一致性

32位源/目的IP地址：标识数据从哪来到哪去

40字节选项数据



#### 链路层：负责相邻设备之间的数据传输；Ether；交换机



链路层协议字段：源mac地址，目的mac地址，上层协议类型，数据，帧尾

mac地址：网络物理硬件地址，用于标识硬件设备



mtu对tcp协议的影响：

​                 tcp在传输层的时候就会获取mtu大小进行计算得到自己的mss大小，并在三次握手时与对方进行协商，取其中较小的一个作为传输大小，发送数据的时候从发送缓冲区中取出的数据大小就不会大于mss大小；tcp在传输层会自动进行数据分段，因此不会在网络层进行数据分片。

![1563418412479](C:\Users\ADMINI~1\AppData\Local\Temp\1563418412479.png)

mtu对udp协议的影响：

​                  因为udp在传输层不会进行数据分段，因此当udp传输的数据大小，大于mtu但是小于64k - 20-8的时候，数据会在网络层进行数据分片，分片了在对端就会进行分片重组，只要有一个分片出问题，都会导致整个udp数据报被丢弃；因此对于udp来说分片越多，传输就越危险。

​               因此用户在应用层进行udp数据分包的时候最好就将数据大小控制在mtu-20-8





