代码块:{}一段代码

普通代码块:方法中定义的代码块,解决变量重名问题
构造块:定义在类中没有任何修饰符,优先于构造方法执行，每当实例化一个对象时，就调用一次构造块
静态代码块:定义在类中，使用static修饰的代码块
优先于构造块执行。
定义在主类中的静态块优先于主方法执行。
在类加载时执行一次。与对象实例化无关。

this:
1.表示本类属性 this.name
2.表示本类方法:
a.表示本类构造方法
this(构造方法参数)，写在构造方法首行。
b.表示本类的普通方法
this.方法名称(参数)
3.表示当前对象。

static:
1.表示静态属性-共享属性-所有该类的对象共同拥有此属性，在方法区保存。
2.表示静态方法-直接通过类名称调用，常见于工具类方法。
Arrays.sort()
Arrays.copyOf()

静态方法能否访问类的普通属性? false.
普通方法能否访问类的静态属性? ture

继承:extends 复用代码
is -a
原则:
1.单继承
要想实现多继承的概念:使用多层继承、内部类、使用接口
class A {}
class B extends A{}
class C extends B{}

2.实例化子类先调用父类构造实例化父类对象后再调用子类构造实例化子类对象

class Person {
	public Person() {
		System.out.println("******");
	}
}

class Student extends Person {
	public Student () {
		// super();
		System.out.println("##########");
	}
}

main() {
	new Student();
}

super:
1.表示父类属性
2.表示父类方法
a.表示父类构造方法
super(父类构造方法参数);

若调用父类有参构造，super(参数)必须显示的写在首行。不再存在调用本类的构造方法

多态:同一个类实例的相同方法在不同情形下有不同的表现形式。

向上转型:参数的统一化
父类 父类引用 = new 子类实例();
天然的向上转型

向下转型
子类 子类引用 = (子类) 父类对象
向下转型需要强制类型转换。
要发生向下转型，先要发生向上转型。
父类需要调用子类扩充的属性或方法时需要向下转型。

内部类:
就是在类的内部进行其他类结构的嵌套操作。
class Outter {
    private String msg = "I am Outter";
    // 以下为内部类定义----------------------------------
    class Inner {
        public void fun() {
            System.out.println(msg);
        }
    }
    // ----------------------------------
    public void test() {
        // 实例化内部类对象
        Inner in = new Inner();
        in.fun();
    }
}
定义内部类后造成类结构复杂。最大的优点在于内部类可以直接访问外部类私有域。

1.定义内部类的原因(优点)
a.内部类可以访问外部类的所有数据，包含被private封装的数据。
b.内部类可以对外部类之外的类进行隐藏，使用内部类也是封装的一种。(人和心脏、车和发动机)
c.使用内部类可以实现多继承概念(了解)。



2.内部类与外部类关系
a.对于非静态内部类(成员内部类),内部类的创建需要依赖外部类的对象，
在没有外部类实例之前无法创建内部类对象。

b.内部类是一个相对独立的个体，与外部类不是is-a关系,仅仅是包在外部类内部而已。

c.内部类可以直接访问外部类的元素(包含私有域),外部类可以间接访问(通过内部类对象)内部类的所有元素(包含私有域)

即:内外部类可以访问彼此的私有属性(内部类直接访问，外部类通过对象间接访问)

3.内部类的分类

3.1 成员内部类-类比普通方法
定义在类中，不加static修饰符

a.成员内部类需要依赖外部类对象，先创建外部类对象后再创建成员内部类对象
b.成员内部类不能拥有静态属性或方法,但可以访问外部类的静态域

声明并创建成员内部类语法:
I.在外部类内部创建成员内部类对象:就和创建普通类一模一样
class Outter {
    // 成员内部类
    class Inner {}
    public void test() {
        Inner in = new Inner();
    }
}
II.在外部类外部创建成员内部类对象:(前提内部类没有被private封装)
语法:
外部类.内部类 内部类引用 = new 外部类().new 内部类();

Outter.Inner in = new Outter().new Inner();

3.2 静态内部类-类比静态方法
定义在类中，使用static修饰
静态内部类与普通外部类没有任何区别，仅仅是定义在一个类的内部而已。

a.静态内部类的创建不需要依赖外部类对象，可以直接创建
在外部类外部创建静态内部类语法:
外部类.内部类 内部类引用 = new 外部类.内部类();

b.静态内部类能拥有普通属性,但是不能访问外部类的普通属性。
成员内部类不能拥有静态域，能访问外部类的静态域
静态内部类不能访问外部类的普通域,能拥有普通域

3.3 方法内部类(局部内部类)-方法中的局部变量
定义:定义在外部类方法中的类。

a.方法内部类不允许使用访问权限修饰符 public private protected均不允许。

b.方法内部类对外部完全隐藏,除了创建这个类的方法可以访问外均不能访问。

c.方法内部类要想使用方法的形参，该形参必须使用final声明(JDK8之后变为隐式的final声明)


3.4 匿名内部类